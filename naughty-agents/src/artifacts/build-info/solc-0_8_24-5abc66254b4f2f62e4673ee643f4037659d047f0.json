{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_24-5abc66254b4f2f62e4673ee643f4037659d047f0",
  "solcVersion": "0.8.24",
  "solcLongVersion": "0.8.24+commit.e11b9ed9",
  "userSourceNameMap": {
    "contracts/WebOfTrust.sol": "project/contracts/WebOfTrust.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/WebOfTrust.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract WebOfTrust {\n    struct Member {\n        uint256 stakedAmount;\n        address invitedBy;\n        bool isActive;\n    }\n\n    mapping(address => Member) public members;\n    mapping(bytes32 => address) public inviterOfCode;\n    uint256 public requiredStake;\n    address public immutable GENESIS_MEMBER;\n\n    event MemberRegistered(address indexed member, address invitedBy);\n    event InviteCodeCreated(bytes32 code, address indexed creator);\n\n    constructor(uint256 _requiredStake) {\n        requiredStake = _requiredStake;\n        GENESIS_MEMBER = msg.sender;\n        // Bootstrap the network\n        members[msg.sender] = Member({stakedAmount: 0, invitedBy: address(0), isActive: true});\n    }\n\n    modifier onlyActiveMember() {\n        require(members[msg.sender].isActive, \"Not an active member\");\n        _;\n    }\n\n    function createInviteCode() external onlyActiveMember returns (bytes32) {\n        // Simple pseudo-random code generation for MVP\n        bytes32 code = keccak256(abi.encodePacked(msg.sender, block.timestamp));\n        inviterOfCode[code] = msg.sender;\n        emit InviteCodeCreated(code, msg.sender);\n        return code;\n    }\n\n    function isMemberActive(address _member) external view returns (bool) {\n        return members[_member].isActive;\n    }\n\n    function register(bytes32 _inviteCode) external payable {\n        require(msg.value >= requiredStake, \"Insufficient stake\");\n        require(!members[msg.sender].isActive, \"Already registered\");\n\n        address inviter = inviterOfCode[_inviteCode];\n        require(inviter != address(0), \"Invalid or used code\");\n\n        // Burn the code\n        delete inviterOfCode[_inviteCode];\n\n        members[msg.sender] = Member({\n            stakedAmount: msg.value,\n            invitedBy: inviter,\n            isActive: true\n        });\n        emit MemberRegistered(msg.sender, inviter);\n    }\n\n    uint256 public constant PRIMARY_SLASH_PERCENT = 10;\n    uint256 public constant DELEGATED_SLASH_PERCENT = 5;\n\n    // Simplified for MVP: Assumes the report is valid.\n    function reportBadReview(address _reviewer) external {\n        Member storage reviewer = members[_reviewer];\n        require(reviewer.isActive, \"Reviewer not active\");\n\n        // 1. Primary Slash (Multiply before dividing for precision)\n        uint256 primarySlash = (reviewer.stakedAmount * PRIMARY_SLASH_PERCENT) / 100;\n        reviewer.stakedAmount -= primarySlash;\n\n        // 2. Delegated Slash\n        address inviterAddr = reviewer.invitedBy;\n        if (inviterAddr != address(0) && inviterAddr != GENESIS_MEMBER) {\n            Member storage inviter = members[inviterAddr];\n            uint256 delegatedSlash = (inviter.stakedAmount * DELEGATED_SLASH_PERCENT) / 100;\n            inviter.stakedAmount -= delegatedSlash;\n        }\n    }\n}\n"
      }
    }
  }
}