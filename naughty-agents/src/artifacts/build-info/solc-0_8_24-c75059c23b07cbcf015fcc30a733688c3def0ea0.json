{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_24-c75059c23b07cbcf015fcc30a733688c3def0ea0",
  "solcVersion": "0.8.24",
  "solcLongVersion": "0.8.24+commit.e11b9ed9",
  "userSourceNameMap": {
    "contracts/ReviewOracle.sol": "project/contracts/ReviewOracle.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/ActionRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract ActionRegistry {\n    // 0: Unknown, 2: Blacklisted\n    mapping(bytes32 => uint8) public actionStatus;\n    address public reviewOracleAddress;\n\n    // Called during deployment/setup (e.g., by Ignition)\n    function setReviewOracleAddress(address _oracleAddress) external {\n        require(reviewOracleAddress == address(0), \"Oracle already set\");\n        reviewOracleAddress = _oracleAddress;\n    }\n\n    modifier onlyReviewOracle() {\n        require(msg.sender == reviewOracleAddress, \"Not authorized\");\n        _;\n    }\n\n    function getActionStatus(bytes32 _actionHash) external view returns (uint8) {\n        return actionStatus[_actionHash];\n    }\n\n    function addToBlacklist(bytes32 _actionHash) external onlyReviewOracle {\n        actionStatus[_actionHash] = 2;\n    }\n}\n"
      },
      "project/contracts/ReviewOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {WebOfTrust} from \"./WebOfTrust.sol\";\nimport {ActionRegistry} from \"./ActionRegistry.sol\";\n\ncontract ReviewOracle {\n    struct ReviewTask {\n        bytes32 actionHash;\n        uint256 votesForBlacklist;\n        bool isResolved;\n    }\n\n    WebOfTrust public webOfTrust;\n    ActionRegistry public actionRegistry;\n    ReviewTask[] public tasks;\n    uint256 constant QUORUM = 3;\n\n    // mapping(taskId => mapping(address => hasVoted))\n    mapping(uint256 => mapping(address => bool)) public hasVoted;\n\n    event ActionFlagged(uint256 indexed taskId, bytes32 actionHash);\n    event VoteCast(uint256 indexed taskId, address indexed voter, bool approve);\n    event VoteResolved(uint256 indexed taskId, bytes32 actionHash, bool blacklisted);\n\n    constructor(address _webOfTrust, address _actionRegistry) {\n        webOfTrust = WebOfTrust(_webOfTrust);\n        actionRegistry = ActionRegistry(_actionRegistry);\n    }\n\n    // Called by the Security Module\n    function flagActionForReview(bytes32 _actionHash) external {\n        // In a real implementation, you might check if there's already an open task for this hash\n        uint256 taskId = tasks.length;\n        tasks.push(ReviewTask({\n            actionHash: _actionHash,\n            votesForBlacklist: 0,\n            isResolved: false\n        }));\n        emit ActionFlagged(taskId, _actionHash);\n    }\n\n    modifier onlyActiveMember() {\n        require(webOfTrust.isMemberActive(msg.sender), \"Not an active member\");\n        _;\n    }\n\n    function castBlacklistVote(uint256 _taskId, bool _approveBlacklist) external onlyActiveMember {\n        require(_taskId < tasks.length, \"Invalid task ID\");\n        ReviewTask storage task = tasks[_taskId];\n        require(!task.isResolved, \"Task already resolved\");\n        require(!hasVoted[_taskId][msg.sender], \"Already voted\");\n\n        hasVoted[_taskId][msg.sender] = true;\n        if (_approveBlacklist) {\n            task.votesForBlacklist++;\n        }\n\n        emit VoteCast(_taskId, msg.sender, _approveBlacklist);\n    }\n\n    function resolveBlacklistVote(uint256 _taskId) external {\n        require(_taskId < tasks.length, \"Invalid task ID\");\n        ReviewTask storage task = tasks[_taskId];\n        require(!task.isResolved, \"Task already resolved\");\n\n        if (task.votesForBlacklist >= QUORUM) {\n            actionRegistry.addToBlacklist(task.actionHash);\n            task.isResolved = true;\n            emit VoteResolved(_taskId, task.actionHash, true);\n        }\n        // In a full implementation, you might handle the \"no\" vote case,\n        // e.g., if a certain number of \"no\" votes are cast, or after a timeout.\n        // For the MVP, we only resolve on blacklisting.\n    }\n}\n"
      },
      "project/contracts/WebOfTrust.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract WebOfTrust {\n    struct Member {\n        uint256 stakedAmount;\n        address invitedBy;\n        bool isActive;\n    }\n\n    mapping(address => Member) public members;\n    mapping(bytes32 => address) public inviterOfCode;\n    uint256 public requiredStake;\n    address public immutable GENESIS_MEMBER;\n\n    event MemberRegistered(address indexed member, address invitedBy);\n    event InviteCodeCreated(bytes32 code, address indexed creator);\n\n    constructor(uint256 _requiredStake) {\n        requiredStake = _requiredStake;\n        GENESIS_MEMBER = msg.sender;\n        // Bootstrap the network\n        members[msg.sender] = Member({stakedAmount: 0, invitedBy: address(0), isActive: true});\n    }\n\n    modifier onlyActiveMember() {\n        require(members[msg.sender].isActive, \"Not an active member\");\n        _;\n    }\n\n    function createInviteCode() external onlyActiveMember returns (bytes32) {\n        // Simple pseudo-random code generation for MVP\n        bytes32 code = keccak256(abi.encodePacked(msg.sender, block.timestamp));\n        inviterOfCode[code] = msg.sender;\n        emit InviteCodeCreated(code, msg.sender);\n        return code;\n    }\n\n    function isMemberActive(address _member) external view returns (bool) {\n        return members[_member].isActive;\n    }\n\n    function register(bytes32 _inviteCode) external payable {\n        require(msg.value >= requiredStake, \"Insufficient stake\");\n        require(!members[msg.sender].isActive, \"Already registered\");\n\n        address inviter = inviterOfCode[_inviteCode];\n        require(inviter != address(0), \"Invalid or used code\");\n\n        // Burn the code\n        delete inviterOfCode[_inviteCode];\n\n        members[msg.sender] = Member({\n            stakedAmount: msg.value,\n            invitedBy: inviter,\n            isActive: true\n        });\n        emit MemberRegistered(msg.sender, inviter);\n    }\n\n    uint256 public constant PRIMARY_SLASH_PERCENT = 10;\n    uint256 public constant DELEGATED_SLASH_PERCENT = 5;\n\n    // Simplified for MVP: Assumes the report is valid.\n    function reportBadReview(address _reviewer) external {\n        Member storage reviewer = members[_reviewer];\n        require(reviewer.isActive, \"Reviewer not active\");\n\n        // 1. Primary Slash (Multiply before dividing for precision)\n        uint256 primarySlash = (reviewer.stakedAmount * PRIMARY_SLASH_PERCENT) / 100;\n        reviewer.stakedAmount -= primarySlash;\n\n        // 2. Delegated Slash\n        address inviterAddr = reviewer.invitedBy;\n        if (inviterAddr != address(0) && inviterAddr != GENESIS_MEMBER) {\n            Member storage inviter = members[inviterAddr];\n            uint256 delegatedSlash = (inviter.stakedAmount * DELEGATED_SLASH_PERCENT) / 100;\n            inviter.stakedAmount -= delegatedSlash;\n        }\n    }\n}\n"
      }
    }
  }
}